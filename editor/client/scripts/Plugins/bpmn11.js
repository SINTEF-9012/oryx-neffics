/** * Copyright (c) 2008-2009 * Sven Wagner-Boysen * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.BPMN11 = {	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));		this.facade.registerOnEvent('layout.bpmn11.pool', this.handleLayoutPool.bind(this));		this.facade.registerOnEvent('layout.bpmn11.lane', this.handleLayoutLane.bind(this));	},		/**	 * If a pool is selected and contains no lane,	 * a lane is created automagically	 */	onSelectionChanged: function(event) {		if(event.elements && event.elements.length === 1) {			var shape = event.elements[0];			if(shape.getStencil().idWithoutNs() === "Pool") {				if(shape.getChildNodes().length === 0) {					// create a lane inside the selected pool					var option = {							type:"http://b3mn.org/stencilset/bpmn1.1#Lane",							position:{x:0,y:0},							namespace:shape.getStencil().namespace(),							parent:shape					};					this.facade.createShape(option);					this.facade.getCanvas().update();				}			}		}	},			/**	 * DragDocker.Docked Handler	 *	 */		handleDockerDocked: function(options) {				var edge = options.parent;		var edgeSource = options.target;				if(edge.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#SequenceFlow") {			var isGateway = edgeSource.getStencil().groups().find(function(group) {					if(group == "Gateways") 						return group;				});			if(!isGateway && (edge.properties["oryx-conditiontype"] == "Expression"))				// show diamond on edge source				edge.setProperty("oryx-showdiamondmarker", true);			else 				// do not show diamond on edge source				edge.setProperty("oryx-showdiamondmarker", false);						// update edge rendering			//edge.update();						this.facade.getCanvas().update();		}	},		/**	 * PropertyWindow.PropertyChanged Handler	 */	handlePropertyChanged: function(option) {				var shapes = option.elements;		var propertyKey = option.key;		var propertyValue = option.value;				var changed = false;		shapes.each(function(shape){			if((shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#SequenceFlow") &&				(propertyKey === "oryx-conditiontype")) {								if(propertyValue != "Expression")					// Do not show the Diamond					shape.setProperty("oryx-showdiamondmarker", false);				else {					var incomingShapes = shape.getIncomingShapes();										if(!incomingShapes) {						shape.setProperty("oryx-showdiamondmarker", true);					}										var incomingGateway = incomingShapes.find(function(aShape) {						var foundGateway = aShape.getStencil().groups().find(function(group) {							if(group == "Gateways") 								return group;						});						if(foundGateway)							return foundGateway;					});										if(!incomingGateway) 						// show diamond on edge source						shape.setProperty("oryx-showdiamondmarker", true);					else						// do not show diamond						shape.setProperty("oryx-showdiamondmarker", false);				}								changed = true;			}		});				if(changed) {this.facade.getCanvas().update();}			},	/**	 * "layout.bpmn11.pool" handler	 * @param {Object} event	 */		handleLayoutPool: function(event) {		var shape = event.shape;		var lanes = shape.getChildNodes(false).findAll(function(node) {			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");		});		if(lanes.length > 0) {						// only one lane in pool			if(lanes.length == 1) {								// test whether the sole lane has child lanes				var childLanes = lanes.first().getChildNodes(false).findAll(function(node) {					return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");				});				if(childLanes.length > 0) {					lanes.first().setProperty("oryx-showcaption", true);				} else {					if(lanes.first().properties["oryx-name"].trim().length > 0) {						lanes.first().setProperty("oryx-showcaption", true);					} else {						lanes.first().setProperty("oryx-showcaption", false);					}					// adapt height and width of the lane by size of the pool					// the lowerRight bound is equal to that of the containing pool					var singleLane = lanes.first();					var laneUpperLeft = singleLane.bounds.upperLeft();					laneUpperLeft.x = 30;					laneUpperLeft.y = 0;					var laneLowerRight = singleLane.bounds.lowerRight();					laneLowerRight.x = shape.bounds.width();					laneLowerRight.y = shape.bounds.height();					singleLane.bounds.set(laneUpperLeft, laneLowerRight);					return;				}			} else {				lanes.each(function(lane) {					lane.setProperty("oryx-showcaption", true);				});			}						lanes = lanes.sortBy(function(lane) {				return lane.bounds.upperLeft().y;			});									var shapeWidth = shape.bounds.width();			lanes.each(function(lane) {				if(lane.isChanged)					shapeWidth = lane.bounds.width() + 30;			});									// get deepest childs in each branch			var firstLanes = lanes.clone();			var turn = 1;				do {										var allChildLanes = new Array();					var parentLanes = lanes.findAll(function(lane) {											var childLanes = lane.getChildNodes(false).findAll(function(node) {							return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");							});												if(childLanes.length > 0) {								allChildLanes = allChildLanes.concat(childLanes);								return true;							}							});												// set bounds of deepest child lanes						var shapeUpperLeft = shape.bounds.upperLeft();						allChildLanes.each(function(lane) {							var upperLeft = lane.bounds.upperLeft();							var lowerRight = lane.bounds.lowerRight();							lowerRight.x = shapeWidth-30*turn;							lane.bounds.set(upperLeft, lowerRight);						});										lanes = allChildLanes.clone();					turn++;									} while(parentLanes.length > 0);						var shapeHeight = 0;			var topBound = 0;			firstLanes.each(function(lane) {				var ul = lane.bounds.upperLeft();				var lr = lane.bounds.lowerRight();				ul.y = shapeHeight;				lr.y = ul.y + lane.bounds.height();				shapeHeight += lane.bounds.height();				ul.x = 30;				lr.x = shapeWidth;				lane.bounds.set(ul, lr);			});						var upl = shape.bounds.upperLeft();			shape.bounds.set(upl.x, upl.y, upl.x + shapeWidth, upl.y + shapeHeight);		}	},		/**	 * "layout.bpmn11.lane" handler	 * @param {Object} event	 */	handleLayoutLane: function(event) {				var shape = event.shape;		var lanes = shape.getChildNodes(false).findAll(function(node) {			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");		});				if(lanes.length > 0) {			lanes = lanes.sortBy(function(lane) {				return lane.bounds.upperLeft().y;			});						var shapeWidth = shape.bounds.width();						lanes.each(function(lane) {				if(lane.isChanged) {					shapeWidth = lane.bounds.width()+30;				}			});						var shapeHeight = 0;			var topBound = 0;			lanes.each(function(lane) {				var ul = lane.bounds.upperLeft();				var lr = lane.bounds.lowerRight();				ul.y = shapeHeight;				lr.y = ul.y + lane.bounds.height();				shapeHeight += lane.bounds.height();				ul.x = 30;				lr.x = shapeWidth;				lane.bounds.set(ul, lr);			});						var upl = shape.bounds.upperLeft();			shape.bounds.set(upl.x, upl.y, upl.x + shapeWidth, upl.y + shapeHeight);		}	}};ORYX.Plugins.BPMN11 = Clazz.extend(ORYX.Plugins.BPMN11);